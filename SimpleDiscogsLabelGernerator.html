<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Simple Discogs Label Generator</title>
  <style>
    /* App UI (slim, moderno) */
    :root {
      --bg: #fafafa;
      --card: #ffffff;
      --text: #1a1a1a;
      --muted: #6b7280;
      --border: #e5e7eb;
      --shadow: 0 1px 10px rgba(0,0,0,0.05);
      --accent: #111827;
      --danger: #b91c1c;
      --ok: #047857;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      background: var(--bg);
      color: var(--text);
    }
    a { color: inherit; }
    .app {
      max-width: 1100px;
      margin: 18px auto;
      padding: 0 14px;
      display: grid;
      grid-template-columns: 420px 1fr;
      gap: 14px;
      align-items: start;
    }
    @media (max-width: 980px) {
      .app { grid-template-columns: 1fr; }
    }
    .panel {
      background: var(--card);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      border-radius: 10px;
      overflow: hidden;
    }
    .panelHeader {
      padding: 14px 14px 10px 14px;
      border-bottom: 1px solid var(--border);
    }
    .titleRow {
      display: flex;
      gap: 10px;
      align-items: baseline;
      justify-content: space-between;
    }
    .title {
      font-size: 16px;
      font-weight: 700;
      letter-spacing: -0.2px;
    }
    .subtitle {
      margin-top: 6px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
    }
    .panelBody { padding: 14px; }
    .row { display: flex; gap: 10px; }
    .row > * { flex: 1; }
    .field { margin-bottom: 12px; }
    label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    input[type="text"], input[type="password"], input[type="number"] {
      width: 100%;
      border: 1px solid var(--border);
      background: white;
      padding: 10px 10px;
      border-radius: 8px;
      font-size: 13px;
      outline: none;
    }
    input[type="text"]:focus, input[type="password"]:focus, input[type="number"]:focus {
      border-color: #cbd5e1;
      box-shadow: 0 0 0 3px rgba(148,163,184,0.25);
    }
    .hint {
      margin-top: 6px;
      font-size: 11px;
      color: var(--muted);
      line-height: 1.35;
    }
    .btnRow { display: flex; gap: 10px; flex-wrap: wrap; }
    button {
      border: 1px solid var(--border);
      background: white;
      color: var(--text);
      padding: 10px 10px;
      border-radius: 8px;
      font-size: 13px;
      cursor: pointer;
      transition: transform 0.05s ease, background-color 0.15s ease, border-color 0.15s ease;
      user-select: none;
    }
    button.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: white;
    }
    button:disabled {
      opacity: 0.55;
      cursor: not-allowed;
    }
    button:active { transform: translateY(1px); }
    .status {
      margin-top: 12px;
      font-size: 12px;
      color: var(--muted);
      line-height: 1.4;
      white-space: pre-wrap;
    }
    .status .ok { color: var(--ok); font-weight: 600; }
    .status .err { color: var(--danger); font-weight: 600; }
    .split {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
      margin: 6px 0 10px 0;
    }
    .smallBtns { display: flex; gap: 8px; }
    .searchBox { margin-top: 10px; }
    .list {
      max-height: 430px;
      overflow: auto;
      border: 1px solid var(--border);
      border-radius: 8px;
    }
    .listItem {
      display: block;
      padding: 10px 10px;
      border-bottom: 1px solid #f3f4f6;
      cursor: pointer;
      user-select: none;
      transition: background-color 0.15s ease, border-color 0.15s ease;
    }
    .listItem:hover {
      background: #fafafa;
    }
    .listItem:last-child { border-bottom: none; }
    .listItem.selected {
      background: rgba(17, 24, 39, 0.06);
      outline: 1px solid rgba(17, 24, 39, 0.12);
    }
    .listTitle { font-size: 13px; font-weight: 600; line-height: 1.3; }
    .listMeta { margin-top: 3px; font-size: 11px; color: var(--muted); line-height: 1.3; }
    .pill {
      display: inline-block;
      padding: 2px 8px;
      border: 1px solid var(--border);
      border-radius: 999px;
      font-size: 11px;
      color: var(--muted);
      background: #fff;
      margin-left: 8px;
      vertical-align: middle;
    }

    /* Labels (impressão) – baseado no design slim atual do projecto */
    .labelsRoot {
      background: var(--card);
      border: 1px solid var(--border);
      box-shadow: var(--shadow);
      border-radius: 10px;
      overflow: hidden;
    }
    .labelsHeader {
      padding: 14px;
      border-bottom: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .labelsHeader .top {
      display: flex;
      gap: 10px;
      align-items: center;
      justify-content: space-between;
    }
    .labelsHeader .left { display: flex; gap: 10px; align-items: baseline; }
    .labelsHeader .count { font-size: 12px; color: var(--muted); }
    .labelsHeader .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      align-items: center;
      padding-top: 8px;
      border-top: 1px solid var(--border);
    }
    .labelsHeader .control-group {
      display: flex;
      gap: 6px;
      align-items: center;
    }
    .labelsHeader .control-group label {
      font-size: 11px;
      color: var(--muted);
      margin: 0;
      white-space: nowrap;
    }
    .labelsHeader .control-group input[type="color"] {
      width: 30px;
      height: 28px;
      border: 1px solid var(--border);
      border-radius: 4px;
      cursor: pointer;
      padding: 2px;
    }
    .labelsHeader .control-group input[type="number"] {
      width: 50px;
      padding: 6px;
      font-size: 12px;
    }
    .labelsHeader .control-group button {
      padding: 6px 10px;
      font-size: 11px;
    }
    .labelsBody { padding: 0; }

    /* Output: lista vertical contínua */
    .labelsStack {
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .labelCard {
      background: white;
      border: 1px solid #e9edf3;
      border-radius: 12px;
      box-shadow: 0 1px 10px rgba(0,0,0,0.04);
      padding: 14px 16px;
      overflow: hidden;
    }
    .label {
      display: flex;
      gap: 20px;
    }
    .label-cover {
      flex-shrink: 0;
      width: 150px;
      height: 150px;
    }
    .label-cover img {
      width: 100%;
      height: 100%;
      object-fit: cover;
      border-radius: 4px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.1);
      background: #f3f4f6;
    }
    .label-content {
      flex: 1;
      display: flex;
      flex-direction: column;
      position: relative;
      min-width: 0;
    }
    .label-header {
      font-weight: 600;
      font-size: 16px;
      margin-bottom: 4px;
      color: #1a1a1a;
      letter-spacing: -0.3px;
    }
    .label-title {
      font-size: 13px;
      margin-bottom: 15px;
      color: #666;
      font-weight: 400;
    }
    .label-table {
      font-size: 11px;
      margin: 10px 0;
      width: 100%;
      border-collapse: collapse;
      cursor: pointer;
    }
    .label-table:hover {
      opacity: 0.95;
    }
    .label-table th {
      font-size: inherit;
      padding: 5px 8px;
      text-align: left;
      font-weight: 600;
      color: #888;
      border-bottom: 1px solid #e5e7eb;
    }
    .label-table th.hidden {
      display: none;
    }
    .label-table td.hidden {
      display: none;
    }
    .label-table td {
      padding: 5px 8px;
      vertical-align: middle;
    }
    .label-table tbody tr {
      border-bottom: 1px solid #f0f0f0;
    }
    .label-table tbody tr:last-child { 
      border-bottom: none; 
    }
    .label-table tbody tr td {
      border-bottom: 1px solid #f0f0f0;
    }
    .label-table tbody tr:last-child td {
      border-bottom: none;
    }
    .label-table thead tr {
      border-bottom: 1px solid #e5e7eb;
    }
    .track-position {
      font-weight: 500;
      color: #888;
      font-size: 10px;
      width: 30px;
      white-space: nowrap;
    }
    .track-title {
      color: #1a1a1a;
      font-weight: 400;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 520px;
    }
    .track-duration {
      color: #888;
      font-size: 10px;
      white-space: nowrap;
      text-align: right;
      width: 52px;
    }
    .track-bpm, .track-key {
      color: #888;
      font-size: 10px;
      white-space: nowrap;
      text-align: center;
      width: 50px;
      padding: 5px 4px;
      border: 1px solid transparent;
      border-radius: 3px;
      transition: background-color 0.15s ease;
    }
    .track-bpm:hover, .track-key:hover {
      background-color: #f9fafb;
    }
    .track-bpm:focus, .track-key:focus {
      outline: none;
      border-color: #cbd5e1;
      background-color: white;
    }
    .track-bpm.hidden, .track-key.hidden {
      display: none;
    }
    .label-table th.track-bpm.hidden,
    .label-table th.track-key.hidden {
      display: none;
    }
    .label-notes {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px solid #f0f0f0;
      font-size: 11px;
      color: #666;
      display: none;
      width: 100%;
    }
    .label-notes.visible {
      display: block;
    }
    .label-notes-content {
      width: 100%;
      min-height: 40px;
      border: none;
      background: transparent;
      font-size: 11px;
      font-family: inherit;
      color: #666;
      resize: vertical;
      outline: none;
      padding: 4px 0;
      white-space: pre-wrap;
      word-wrap: break-word;
    }
    .label-notes-content:focus {
      color: #1a1a1a;
    }
    .label-notes-content[data-placeholder]:empty:before,
    .label-notes-content[data-placeholder]:not(:focus):empty:before {
      content: attr(data-placeholder);
      color: #999;
      font-style: italic;
    }
    .label-notes-content[data-placeholder]:focus:empty:before {
      content: "";
    }
    @media print {
      .label-notes-content[data-placeholder]:empty:before {
        content: "" !important;
      }
    }
    .label-cover {
      cursor: pointer;
      position: relative;
    }
    .label-cover:hover {
      opacity: 0.9;
    }
    .label-footer {
      font-size: 9px;
      margin-top: auto;
      padding-top: 12px;
      border-top: 1px solid #f0f0f0;
      color: #888;
      line-height: 1.5;
    }
    .label-footer strong { color: #1a1a1a; font-weight: 600; }
    .label-footer em { color: #666; font-style: normal; }
    .qr-code {
      position: absolute;
      top: 0;
      right: 0;
      width: 45px;
      height: 45px;
      opacity: 0.9;
      image-rendering: pixelated;
    }
    .coverPlaceholder {
      width: 100%;
      height: 100%;
      border-radius: 4px;
      background: linear-gradient(135deg, #f3f4f6, #e5e7eb);
    }

    @media print {
      body { background: white; }
      /* Don't hide the entire app (labels are inside). Hide only the controls panel. */
      #controlsPanel { display: none !important; }
      .app {
        display: block !important;
        max-width: none !important;
        margin: 0 !important;
        padding: 0 !important;
      }
      .labelsRoot { border: none; box-shadow: none; }
      .labelsHeader { display: none; }
      .labelsStack { padding: 0; gap: 10px; }
      .label-notes:not(.visible) { display: none !important; }
      .label-notes-content { 
        color: #666 !important; 
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
      }
      .label-notes-content:empty,
      .label-notes-content:empty:before {
        display: none !important;
        content: "" !important;
      }
      .labelCard {
        box-shadow: none;
        border: 1px solid #e5e7eb;
        border-radius: 10px;
        padding: 12px 14px;
        break-inside: avoid;
        page-break-inside: avoid;
      }
    }

    /* Loading */
    .statusRow {
      display: flex;
      gap: 10px;
      align-items: flex-start;
      margin-top: 12px;
    }
    .spinner {
      width: 14px;
      height: 14px;
      border-radius: 999px;
      border: 2px solid #e5e7eb;
      border-top-color: #111827;
      animation: spin 0.8s linear infinite;
      display: none;
      margin-top: 2px;
      flex: 0 0 auto;
    }
    .busy .spinner { display: inline-block; }
    @keyframes spin { to { transform: rotate(360deg); } }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/qrcode@1.5.4/build/qrcode.min.js"></script>
</head>
<body>
  <div class="app">
    <section class="panel" id="controlsPanel" aria-label="Controls">
      <div class="panelHeader">
        <div class="titleRow">
          <div class="title">Simple Discogs Label Generator</div>
          <span class="pill">no server</span>
        </div>
        <div class="subtitle">
          Enter your Discogs token, load your collection, and generate printable HTML labels.
        </div>
      </div>
      <div class="panelBody">
        <div class="field">
          <label for="token">Discogs token</label>
          <input id="token" type="password" placeholder="paste your token here (Personal Access Token)" autocomplete="off" />
          <div class="hint">Generate one at `https://www.discogs.com/settings/developers`.</div>
        </div>

        <div class="field">
          <label for="corsProxy">CORS proxy (optional)</label>
          <input id="corsProxy" type="text" placeholder="e.g. https://corsproxy.io/?" autocomplete="off" />
          <div class="hint">
            If your browser blocks requests due to CORS, add a proxy prefix (e.g. `https://corsproxy.io/?`).
            If it works without a proxy, leave this empty.
          </div>
        </div>

        <div class="row">
          <div class="field">
            <label for="perPage">Per page (API)</label>
            <input id="perPage" type="number" min="25" max="100" value="100" />
          </div>
          <div class="field">
            <label for="maxReleases">Max releases (0 = all)</label>
            <input id="maxReleases" type="number" min="0" value="0" />
          </div>
        </div>

        <div class="row">
          <div class="field">
            <label for="requestDelay">Delay between requests (ms)</label>
            <input id="requestDelay" type="number" min="0" value="1200" />
            <div class="hint">If you use a CORS proxy, you may need to increase this (e.g. 2000–4000ms).</div>
          </div>
          <div class="field">
            <label>Options</label>
            <div style="display:flex;flex-direction:column;gap:8px;margin-top:2px;">
              <label style="display:flex;gap:8px;align-items:center;margin:0;color:var(--text);font-size:12px;">
                <input id="includeTracklist" type="checkbox" checked />
                Include tracklist (slower; 1 request per release)
              </label>
              <label style="display:flex;gap:8px;align-items:center;margin:0;color:var(--text);font-size:12px;">
                <input id="stopOnError" type="checkbox" />
                Stop on first error (default: continue and skip the release)
              </label>
            </div>
          </div>
        </div>

        <div class="btnRow">
          <button id="btnStart" class="primary">Verify token + Load collection</button>
          <button id="btnGenerate" class="primary">Generate labels</button>
          <button id="btnExport">Export HTML</button>
          <button id="btnExportList">Export Release List</button>
        </div>

        <div class="statusRow" id="statusRow">
          <div class="spinner" aria-hidden="true"></div>
          <div class="status" id="status"></div>
        </div>

        <div class="split" style="margin-top:14px;">
          <div style="font-size:12px;color:var(--muted);">
            Releases: <span id="releaseCount">0</span>
            <span class="pill" id="selectedCount">0 selected</span>
          </div>
          <div class="smallBtns">
            <button id="btnAll">Select visible</button>
            <button id="btnNone">Clear</button>
          </div>
        </div>

        <div class="field searchBox">
          <label for="filter">Filter</label>
          <input id="filter" type="text" placeholder="filter by artist/title/year/label... (use ; to separate)" />
          <div class="hint">Example: <code>2001; 2002; Guetta</code> shows items matching any of those terms.</div>
        </div>

        <div class="list" id="releaseList" aria-label="Release list"></div>
      </div>
    </section>

    <section class="labelsRoot" aria-label="Generated labels">
      <div class="labelsHeader">
        <div class="top">
          <div class="left">
            <div class="title">Preview</div>
            <div class="count" id="outputCount">0 labels</div>
          </div>
          <div class="count">Tip: use Ctrl+P to print.</div>
        </div>
        <div class="controls">
          <div class="control-group">
            <label>Font:</label>
            <button id="btnFontSizeDown" title="Decrease font size">-1pt</button>
            <input type="number" id="fontSizeDisplay" value="0" readonly style="width:40px;text-align:center;" />
            <button id="btnFontSizeUp" title="Increase font size">+1pt</button>
          </div>
          <div class="control-group">
            <label>Color pick:</label>
          </div>
          <div class="control-group">
            <label>Artist(s):</label>
            <input type="color" id="titleColor" value="#1a1a1a" />
          </div>
          <div class="control-group">
            <label>Release:</label>
            <input type="color" id="subtitleColor" value="#666666" />
          </div>
          <div class="control-group">
            <label>Spacing:</label>
            <button id="btnSpacingDown" title="Decrease spacing">-1 line</button>
            <input type="number" id="spacingDisplay" value="0" readonly style="width:40px;text-align:center;" />
            <button id="btnSpacingUp" title="Increase spacing">+1 line</button>
          </div>
        </div>
        <div style="padding: 10px 14px; border-top: 1px solid var(--border); font-size: 11px; color: var(--muted); line-height: 1.5;">
          <strong style="color: var(--text);">Instructions:</strong><br>
          • Click on the cover image to show/hide notes field for that label<br>
          • Click on the track table to show/hide BPM/KEY columns for that label
        </div>
      </div>
      <div class="labelsBody">
        <div class="labelsStack" id="output"></div>
      </div>
    </section>
  </div>

  <script>
    // State
    const state = {
      token: "",
      corsProxy: "",
      identity: null, // {username, id}
      releases: [],   // collection release items
      selected: new Set(), // releaseId
      generatedHtml: "",   // HTML labels (inner)
      lastError: null,
      isBusy: false,
      // Configurações de estilo
      fontSizeOffset: 0, // offset em pt
      titleColor: "#1a1a1a",
      subtitleColor: "#666666",
      spacingOffset: 0, // offset em linhas
      // Dados por label
      labelNotes: new Map(), // releaseId -> notes
      trackBpm: new Map(), // releaseId -> {trackIndex -> bpm}
      trackKey: new Map(), // releaseId -> {trackIndex -> key}
      labelShowBpmKey: new Map(), // releaseId -> boolean (individual toggle)
      releaseData: new Map(), // releaseId -> {meta, qr} (para export)
    };

    // UI helpers
    const $ = (id) => document.getElementById(id);
    const setBusy = (busy) => {
      state.isBusy = busy;
      $("btnStart").disabled = busy;
      $("btnGenerate").disabled = busy;
      $("btnExport").disabled = busy || !state.generatedHtml;
      $("btnAll").disabled = busy || state.releases.length === 0;
      $("btnNone").disabled = busy || state.releases.length === 0;
      const row = $("statusRow");
      if (busy) row.classList.add("busy");
      else row.classList.remove("busy");
    };
    const setStatus = (msg, kind = "info") => {
      const el = $("status");
      if (kind === "ok") el.innerHTML = `<span class="ok">${escapeHtml(msg)}</span>`;
      else if (kind === "err") el.innerHTML = `<span class="err">${escapeHtml(msg)}</span>`;
      else el.textContent = msg;
    };
    const escapeHtml = (s) => (s ?? "").toString()
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll("\"", "&quot;")
      .replaceAll("'", "&#039;");

    const sleep = (ms) => new Promise((r) => setTimeout(r, ms));

    // CORS proxy prefix (optional)
    const withProxy = (url) => {
      const p = (state.corsProxy || "").trim();
      if (!p) return url;
      return p + encodeURIComponent(url);
    };

    // Discogs fetch
    async function discogsFetchJson(url, opts = {}) {
      const finalUrl = withProxy(url);
      const token = state.token;
      const maxRetries = Number.isFinite(opts.maxRetries) ? opts.maxRetries : 5;
      const baseDelayMs = Number.isFinite(opts.baseDelayMs) ? opts.baseDelayMs : 1200;

      let lastErr = null;
      for (let attempt = 0; attempt <= maxRetries; attempt++) {
        try {
          const res = await fetch(finalUrl, {
            method: "GET",
            headers: {
              "Authorization": `Discogs token=${token}`,
              "User-Agent": "DiscogsLabelGenStandalone/1.0 (+https://example.local)",
              "Accept": "application/vnd.discogs.v2+json",
            }
          });

          // 429 (rate limit) - respect Retry-After if present
          if (res.status === 429) {
            const retryAfter = Number(res.headers.get("Retry-After") || "0");
            const waitMs = retryAfter > 0 ? retryAfter * 1000 : Math.min(15000, baseDelayMs * (attempt + 2));
            const body = await res.text().catch(() => "");
            lastErr = new Error(`HTTP 429 (rate limit). Waiting ${waitMs}ms. ${body.slice(0, 120)}`);
            await sleep(waitMs);
            continue;
          }

          if (!res.ok) {
            const text = await res.text().catch(() => "");
            // retry on 5xx
            if (res.status >= 500 && attempt < maxRetries) {
              const waitMs = Math.min(15000, baseDelayMs * (attempt + 2));
              lastErr = new Error(`HTTP ${res.status}. Retrying in ${waitMs}ms. ${text.slice(0, 120)}`);
              await sleep(waitMs);
              continue;
            }
            throw new Error(`HTTP ${res.status} ${res.statusText} — ${text.slice(0, 300)}`);
          }

          return await res.json();
        } catch (e) {
          // Network/CORS/proxy error: TypeError("Failed to fetch")
          lastErr = e;
          if (attempt >= maxRetries) break;
          const waitMs = Math.min(15000, baseDelayMs * (attempt + 2));
          await sleep(waitMs);
        }
      }

      const proxyMsg = state.corsProxy
        ? "This looks like a proxy/CORS failure. Try removing the proxy (if not needed) or increasing the delay."
        : "This looks like a CORS/network issue. If you see CORS errors in the console, try a CORS proxy (field above) or another browser.";
      const errMsg = lastErr?.message || String(lastErr);
      throw new Error(`${errMsg}\nURL: ${url}\n${proxyMsg}`);
    }

    async function loadIdentity() {
      state.token = $("token").value.trim();
      state.corsProxy = $("corsProxy").value.trim();
      if (!state.token) {
        setStatus("Token is missing.", "err");
        return;
      }
      try {
        setStatus("Verifying token (oauth/identity)...");
        const data = await discogsFetchJson("https://api.discogs.com/oauth/identity");
        state.identity = { username: data.username, id: data.id };
        setStatus(`Token OK. User: ${data.username} (id ${data.id}).`, "ok");
      } catch (e) {
        state.identity = null;
        setStatus(`Token verification failed: ${e.message}`, "err");
      }
    }

    function releaseTitleForList(item) {
      const basic = item.basic_information || {};
      const artists = (basic.artists || []).map(a => a.name).filter(Boolean).join(", ");
      const title = basic.title || "No title";
      const year = basic.year ? String(basic.year) : "";
      const label = (basic.labels || []).map(l => l.name).filter(Boolean).slice(0, 2).join(", ");
      return { artists, title, year, label };
    }

    function renderReleaseList() {
      const filterTerms = parseFilterTerms($("filter").value);
      const container = $("releaseList");
      container.innerHTML = "";

      let shown = 0;
      for (const item of state.releases) {
        const basic = item.basic_information || {};
        const id = basic.id;
        if (!id) continue;
        const { artists, title, year, label } = releaseTitleForList(item);
        const hay = `${artists} ${title} ${year} ${label}`.toLowerCase();
        if (filterTerms.length && !filterTerms.some(t => hay.includes(t))) continue;

        shown++;
        const selectedClass = state.selected.has(id) ? "selected" : "";
        const el = document.createElement("div");
        el.className = `listItem ${selectedClass}`;
        el.setAttribute("role", "button");
        el.setAttribute("tabindex", "0");
        el.setAttribute("data-release-id", String(id));
        el.innerHTML = `
          <div class="listTitle">${escapeHtml(artists || "Artist")} — ${escapeHtml(title)}</div>
          <div class="listMeta">
            ${year ? escapeHtml(year) : "—"}
            ${label ? " • " + escapeHtml(label) : ""}
            <span class="pill">id ${escapeHtml(String(id))}</span>
          </div>
        `;
        container.appendChild(el);
      }
      $("releaseCount").textContent = String(shown);
      $("selectedCount").textContent = `${state.selected.size} selected`;
    }

    function parseFilterTerms(raw) {
      return (raw || "")
        .split(";")
        .map(s => s.trim().toLowerCase())
        .filter(Boolean);
    }

    function getVisibleReleaseIds() {
      const filterTerms = parseFilterTerms($("filter").value);
      const ids = [];
      for (const item of state.releases) {
        const basic = item.basic_information || {};
        const id = basic.id;
        if (!id) continue;
        const { artists, title, year, label } = releaseTitleForList(item);
        const hay = `${artists} ${title} ${year} ${label}`.toLowerCase();
        if (filterTerms.length && !filterTerms.some(t => hay.includes(t))) continue;
        ids.push(id);
      }
      return ids;
    }

    async function loadCollection() {
      state.token = $("token").value.trim();
      state.corsProxy = $("corsProxy").value.trim();
      if (!state.token) {
        setStatus("Token is missing.", "err");
        return;
      }
      if (!state.identity) {
        setStatus("First click “Verify token + Load collection”.", "err");
        return;
      }

      const perPage = Math.max(25, Math.min(100, Number($("perPage").value) || 100));
      const maxReleases = Math.max(0, Number($("maxReleases").value) || 0);
      const requestDelay = Math.max(0, Number($("requestDelay").value) || 0);

      try {
        state.releases = [];
        state.selected.clear();
        renderReleaseList();
        setStatus("Loading collection (folder 0)...\nThis may take a while (rate limit ~60/min).");

        let page = 1;
        let totalPages = 1;
        let fetched = 0;

        while (page <= totalPages) {
          const url = `https://api.discogs.com/users/${encodeURIComponent(state.identity.username)}/collection/folders/0/releases?per_page=${perPage}&page=${page}`;
          const data = await discogsFetchJson(url, { baseDelayMs: Math.max(800, requestDelay) });
          const items = data.releases || [];
          totalPages = data.pagination?.pages || 1;

          for (const it of items) {
            state.releases.push(it);
            const id = it.basic_information?.id;
            if (id) state.selected.add(id); // default: select all
            fetched++;
            if (maxReleases > 0 && fetched >= maxReleases) break;
          }

          renderReleaseList();
          setStatus(`Collection: page ${page}/${totalPages} • ${state.releases.length} loaded • ${state.selected.size} selected`);

          if (maxReleases > 0 && fetched >= maxReleases) break;
          page++;
          // Rate limit: ~60/min -> 1100ms entre requests
          await sleep(Math.max(800, requestDelay));
        }

        setStatus(`Collection loaded: ${state.releases.length} releases.`, "ok");
      } catch (e) {
        setStatus(`Error loading collection: ${e.message}`, "err");
      }
    }

    async function startVerifyAndLoad() {
      state.token = $("token").value.trim();
      state.corsProxy = $("corsProxy").value.trim();
      if (!state.token) { setStatus("Token is missing.", "err"); return; }
      setBusy(true);
      try {
        await loadIdentity();
        if (!state.identity) return;
        await loadCollection();
      } finally {
        setBusy(false);
      }
    }

    async function loadReleaseMetadata(releaseId) {
      // Note: endpoint /releases/{id}. No waveforms/BPM/Key in the browser.
      const url = `https://api.discogs.com/releases/${releaseId}`;
      const requestDelay = Math.max(0, Number($("requestDelay").value) || 0);
      const data = await discogsFetchJson(url, { baseDelayMs: Math.max(800, requestDelay) });
      return normalizeReleaseMetadata(releaseId, data);
    }

    function normalizeFromCollectionItem(item) {
      const basic = item.basic_information || {};
      const artists = (basic.artists || []).map(a => a.name).filter(Boolean);
      const labels = (basic.labels || []).map(l => l.name).filter(Boolean);
      const catalogNumbers = (basic.labels || []).map(l => l.catno).filter(Boolean);
      const genres = (basic.genres || []).filter(Boolean);
      const styles = (basic.styles || []).filter(Boolean);
      const year = basic.year || "";
      const title = basic.title || "";
      const coverUrl = basic.cover_image || "";
      // Collection endpoint does not provide full tracklist; generate without table (fast mode).
      return {
        id: basic.id,
        title,
        artist: artists,
        label: labels,
        catalog_numbers: catalogNumbers,
        genres,
        styles,
        year,
        tracklist: [],
        cover_url: coverUrl,
      };
    }

    function normalizeReleaseMetadata(releaseId, data) {
      const artists = (data.artists || []).map(a => a.name).filter(Boolean);
      const labels = (data.labels || []).map(l => l.name).filter(Boolean);
      const catalogNumbers = (data.labels || []).map(l => l.catno).filter(Boolean);
      const genres = (data.genres || []).filter(Boolean);
      const styles = (data.styles || []).filter(Boolean);
      const year = data.year || "";
      const title = data.title || "";
      const images = data.images || [];
      const coverUrl = images[0]?.uri || images[0]?.resource_url || "";
      const tracklist = (data.tracklist || [])
        .filter(t => t && t.type_ === "track")
        .map(t => ({
          position: t.position || "",
          title: t.title || "",
          duration: t.duration || "",
          artist: (t.artists && t.artists[0]?.name) ? t.artists[0].name : ""
        }));

      return {
        id: releaseId,
        title,
        artist: artists,
        label: labels,
        catalog_numbers: catalogNumbers,
        genres,
        styles,
        year,
        tracklist,
        cover_url: coverUrl,
      };
    }

    async function generateQRCodeDataUrl(releaseId) {
      const url = `https://discogs.com/release/${releaseId}`;
      // QRCode library: window.QRCode (CDN). Fallback: retorna string vazia.
      if (!window.QRCode || typeof window.QRCode.toDataURL !== "function") return "";
      return await QRCode.toDataURL(url, { errorCorrectionLevel: "M", margin: 1, width: 180 });
    }

    function buildFooter(meta) {
      const parts = [];
      const label = (meta.label || []).slice(0, 2).join(", ");
      const cat = (meta.catalog_numbers || []).filter(Boolean).slice(0, 2).join(", ");
      const year = meta.year ? String(meta.year) : "";
      const genres = (meta.genres || []).slice(0, 3).join(", ");
      const styles = (meta.styles || []).slice(0, 3).join(", ");

      if (label) parts.push(`<strong>${escapeHtml(label)}</strong>`);
      if (cat) parts.push(escapeHtml(cat));
      if (year) parts.push(escapeHtml(year));
      if (genres) parts.push(escapeHtml(genres));
      if (styles) parts.push(`<em>${escapeHtml(styles)}</em>`);
      parts.push(`Release ID: ${escapeHtml(String(meta.id))}`);
      return parts.join(", ");
    }

    function buildTrackTable(meta, releaseId) {
      const tracks = meta.tracklist || [];
      if (!tracks.length) return "";
      const bpmMap = state.trackBpm.get(releaseId) || {};
      const keyMap = state.trackKey.get(releaseId) || {};
      const showBpmKey = state.labelShowBpmKey.get(releaseId) || false;
      const rows = tracks.map((t, idx) => {
        const pos = t.position || "";
        const title = t.title || "";
        const artist = t.artist || "";
        const dur = t.duration || "";
        const bpm = bpmMap[idx] || "";
        const key = keyMap[idx] || "";
        const bpmClass = showBpmKey ? "" : "hidden";
        const keyClass = showBpmKey ? "" : "hidden";
        
        // Se há artista, mostra "Artist - Title", senão apenas "Title"
        const trackDisplay = artist ? `${escapeHtml(artist)} - ${escapeHtml(title)}` : escapeHtml(title);
        
        return `
          <tr>
            <td class="track-position">${escapeHtml(pos)}</td>
            <td class="track-title" title="${artist ? escapeHtml(artist) + ' - ' : ''}${escapeHtml(title)}">${trackDisplay}</td>
            <td class="track-bpm ${bpmClass}" contenteditable="true" data-release-id="${releaseId}" data-track-index="${idx}" data-field="bpm">${escapeHtml(bpm)}</td>
            <td class="track-key ${keyClass}" contenteditable="true" data-release-id="${releaseId}" data-track-index="${idx}" data-field="key">${escapeHtml(key)}</td>
            <td class="track-duration">${escapeHtml(dur)}</td>
          </tr>
        `;
      }).join("");
      const bpmHeader = showBpmKey ? '<th class="track-bpm">BPM</th>' : '<th class="track-bpm hidden">BPM</th>';
      const keyHeader = showBpmKey ? '<th class="track-key">KEY</th>' : '<th class="track-key hidden">KEY</th>';
      return `<table class="label-table" data-release-id="${releaseId}"><thead><tr><th></th><th></th>${bpmHeader}${keyHeader}<th></th></tr></thead><tbody>${rows}</tbody></table>`;
    }

    function buildLabelPage(meta, qrDataUrl) {
      const artist = (meta.artist || []).join(", ") || "Artist";
      const title = meta.title || "Title";
      const cover = meta.cover_url;
      const releaseId = meta.id;

      const coverHtml = cover
        ? `<img src="${escapeHtml(cover)}" alt="Cover" loading="lazy" referrerpolicy="no-referrer" />`
        : `<div class="coverPlaceholder" aria-label="No cover"></div>`;

      const tableHtml = buildTrackTable(meta, releaseId);
      const footerHtml = buildFooter(meta);
      const notes = state.labelNotes.get(releaseId) || "";
      const notesHtml = `
        <div class="label-notes" data-release-id="${releaseId}">
          <div class="label-notes-content" contenteditable="true" data-placeholder="Add notes about this release..." data-release-id="${releaseId}">${escapeHtml(notes)}</div>
        </div>
      `;

      const qrHtml = qrDataUrl
        ? `<img class="qr-code" src="${escapeHtml(qrDataUrl)}" alt="QR" />`
        : "";

      // Aplicar estilos dinâmicos
      const fontSizeHeader = 16 + state.fontSizeOffset;
      const fontSizeTitle = 13 + state.fontSizeOffset;
      const fontSizeTable = 11 + state.fontSizeOffset;
      const styleAttr = `style="--header-size: ${fontSizeHeader}px; --title-size: ${fontSizeTitle}px; --table-size: ${fontSizeTable}px; --title-color: ${state.titleColor}; --subtitle-color: ${state.subtitleColor};"`;

      return `
        <div class="labelCard" ${styleAttr} data-release-id="${releaseId}">
          <div class="label">
            <div class="label-cover" data-release-id="${releaseId}">${coverHtml}</div>
            <div class="label-content">
              ${qrHtml}
              <div class="label-header" style="font-size: ${fontSizeHeader}px; color: ${state.titleColor};">${escapeHtml(artist)}</div>
              <div class="label-title" style="font-size: ${fontSizeTitle}px; color: ${state.subtitleColor};">${escapeHtml(title)}</div>
              ${tableHtml}
              <div class="label-footer">${footerHtml}</div>
              ${notesHtml}
            </div>
          </div>
        </div>
      `;
    }

    async function generateLabels() {
      state.token = $("token").value.trim();
      state.corsProxy = $("corsProxy").value.trim();
      if (!state.token) { setStatus("Token is missing.", "err"); return; }
      if (!state.identity) { setStatus("First click “Verify token + Load collection”.", "err"); return; }
      if (!state.releases.length) { setStatus("First load your collection.", "err"); return; }

      const selected = Array.from(state.selected);
      if (!selected.length) { setStatus("No releases selected.", "err"); return; }

      setBusy(true);
      try {
        const requestDelay = Math.max(0, Number($("requestDelay").value) || 0);
        const includeTracklist = $("includeTracklist").checked;
        const stopOnError = $("stopOnError").checked;

        setStatus(`Generating labels for ${selected.length} release(s)...\nDelay: ${Math.max(800, requestDelay)}ms • Tracklist: ${includeTracklist ? "yes" : "no"}`);
        const pages = [];
        const errors = [];

        let i = 0;
        const releaseData = new Map(); // releaseId -> {meta, qr}
        for (const releaseId of selected) {
          i++;
          setStatus(`Generating ${i}/${selected.length} (release ${releaseId})...${errors.length ? `\nErrors so far: ${errors.length}` : ""}`);

          try {
            const item = state.releases.find(r => r.basic_information?.id === releaseId);
            const meta = includeTracklist ? await loadReleaseMetadata(releaseId) : normalizeFromCollectionItem(item || { basic_information: { id: releaseId } });
            await sleep(Math.max(800, requestDelay)); // rate limit (Discogs / proxy)

            const qr = await generateQRCodeDataUrl(releaseId);
            releaseData.set(releaseId, { meta, qr });
            pages.push(buildLabelPage(meta, qr));
          } catch (e) {
            errors.push({ releaseId, message: e?.message || String(e) });
            if (stopOnError) throw e;
          }
        }
        state.releaseData = releaseData; // Guardar para export

        state.generatedHtml = pages.join("\n");
        $("output").innerHTML = state.generatedHtml;
        $("outputCount").textContent = `${pages.length} labels`;
        applyPreviewSettings();
        attachLabelEventListeners();
        if (errors.length) {
          setStatus(`Generated labels: ${pages.length}. Skipped errors: ${errors.length}.\nFirst error: release ${errors[0].releaseId} — ${errors[0].message}`, "ok");
        } else {
          setStatus(`Generated labels: ${pages.length}.`, "ok");
        }
      } catch (e) {
        setStatus(`Error generating labels: ${e.message}`, "err");
      } finally {
        setBusy(false);
      }
    }

    function applyPreviewSettings() {
      const fontSizeHeader = 16 + state.fontSizeOffset;
      const fontSizeTitle = 13 + state.fontSizeOffset;
      const fontSizeTable = 11 + state.fontSizeOffset;
      const spacing = 12 + (state.spacingOffset * 12); // 12px base + offset em múltiplos de 12px

      // Aplicar tamanhos de fonte
      document.querySelectorAll(".label-header").forEach(el => {
        el.style.fontSize = `${fontSizeHeader}px`;
        el.style.color = state.titleColor;
      });
      document.querySelectorAll(".label-title").forEach(el => {
        el.style.fontSize = `${fontSizeTitle}px`;
        el.style.color = state.subtitleColor;
      });
      document.querySelectorAll(".label-table").forEach(el => {
        el.style.fontSize = `${fontSizeTable}px`;
      });

      // Aplicar espaçamento
      const stack = $("output");
      if (stack) {
        stack.style.gap = `${spacing}px`;
      }

      // Aplicar visibilidade BPM/KEY individual por label
      document.querySelectorAll(".label-table").forEach(table => {
        const releaseId = Number(table.getAttribute("data-release-id"));
        if (!releaseId) return;
        
        const showBpmKey = state.labelShowBpmKey.get(releaseId) || false;
        table.querySelectorAll(".track-bpm, .track-key").forEach(el => {
          if (showBpmKey) {
            el.classList.remove("hidden");
          } else {
            el.classList.add("hidden");
          }
        });
        table.querySelectorAll("th.track-bpm, th.track-key").forEach(el => {
          if (showBpmKey) {
            el.classList.remove("hidden");
          } else {
            el.classList.add("hidden");
          }
        });
      });
    }

    function attachLabelEventListeners() {
      // Clique na imagem para mostrar/ocultar notas
      document.querySelectorAll(".label-cover").forEach(cover => {
        cover.removeEventListener("click", handleCoverClick);
        cover.addEventListener("click", handleCoverClick);
      });

      // Edição de BPM/KEY
      document.querySelectorAll(".track-bpm, .track-key").forEach(cell => {
        cell.removeEventListener("blur", handleBpmKeyEdit);
        cell.addEventListener("blur", handleBpmKeyEdit);
        // Prevenir toggle ao editar
        cell.addEventListener("click", (e) => {
          e.stopPropagation();
        });
      });

      // Toggle BPM/KEY ao clicar na tabela
      document.querySelectorAll(".label-table").forEach(table => {
        table.removeEventListener("click", handleTableClick);
        table.addEventListener("click", handleTableClick);
      });

      // Edição de notas
      document.querySelectorAll(".label-notes-content").forEach(content => {
        content.removeEventListener("blur", handleNotesEdit);
        content.addEventListener("blur", handleNotesEdit);
        content.removeEventListener("input", handleNotesEdit);
        content.addEventListener("input", handleNotesEdit);
      });
    }

    function handleCoverClick(e) {
      const cover = e.currentTarget;
      const releaseId = Number(cover.getAttribute("data-release-id"));
      if (!releaseId) return;

      const labelCard = cover.closest(".labelCard");
      if (!labelCard) return;

      const notesDiv = labelCard.querySelector(".label-notes");
      if (notesDiv) {
        notesDiv.classList.toggle("visible");
        if (notesDiv.classList.contains("visible")) {
          const content = notesDiv.querySelector(".label-notes-content");
          if (content) {
            content.focus();
            // Move cursor to end
            const range = document.createRange();
            range.selectNodeContents(content);
            range.collapse(false);
            const sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          }
        }
      }
    }

    function handleTableClick(e) {
      // Não fazer toggle se clicou numa célula editável (BPM/KEY)
      if (e.target.classList.contains("track-bpm") || e.target.classList.contains("track-key")) {
        return;
      }
      
      const table = e.currentTarget;
      const releaseId = Number(table.getAttribute("data-release-id"));
      if (!releaseId) return;

      const currentState = state.labelShowBpmKey.get(releaseId) || false;
      state.labelShowBpmKey.set(releaseId, !currentState);
      
      // Atualizar visibilidade
      const showBpmKey = !currentState;
      const labelCard = table.closest(".labelCard");
      if (labelCard) {
        labelCard.querySelectorAll(".track-bpm, .track-key").forEach(cell => {
          if (showBpmKey) {
            cell.classList.remove("hidden");
          } else {
            cell.classList.add("hidden");
          }
        });
        labelCard.querySelectorAll("th.track-bpm, th.track-key").forEach(header => {
          if (showBpmKey) {
            header.classList.remove("hidden");
          } else {
            header.classList.add("hidden");
          }
        });
      }
    }

    function handleBpmKeyEdit(e) {
      const cell = e.target;
      const releaseId = Number(cell.getAttribute("data-release-id"));
      const trackIndex = Number(cell.getAttribute("data-track-index"));
      const field = cell.getAttribute("data-field");
      const value = cell.textContent.trim();

      if (!releaseId || isNaN(trackIndex) || !field) return;

      if (field === "bpm") {
        if (!state.trackBpm.has(releaseId)) {
          state.trackBpm.set(releaseId, {});
        }
        state.trackBpm.get(releaseId)[trackIndex] = value;
      } else if (field === "key") {
        if (!state.trackKey.has(releaseId)) {
          state.trackKey.set(releaseId, {});
        }
        state.trackKey.get(releaseId)[trackIndex] = value;
      }
    }

    function handleNotesEdit(e) {
      const content = e.target;
      const releaseId = Number(content.getAttribute("data-release-id"));
      if (!releaseId) return;
      
      // Get text content, handling both textContent and innerText
      const value = (content.textContent || content.innerText || "").trim();
      state.labelNotes.set(releaseId, value);
      
      // Update the element to show placeholder if empty
      if (!value && content.hasAttribute("data-placeholder")) {
        // Force re-render to show placeholder
        const placeholder = content.getAttribute("data-placeholder");
        if (!content.textContent.trim()) {
          content.textContent = "";
        }
      }
    }

    function exportHtml() {
      if (!state.generatedHtml || !state.releaseData) {
        setStatus("Nothing to export. Generate labels first.", "err");
        return;
      }

      // Reconstruir HTML com todas as configurações aplicadas
      const selected = Array.from(state.selected);
      const pages = [];
      
      // Reconstruir cada label com as configurações atuais
      for (const releaseId of selected) {
        const data = state.releaseData.get(releaseId);
        if (!data) continue;

        const meta = data.meta;
        const qr = data.qr;
        
        // Reconstruir com configurações atuais
        const artist = (meta.artist || []).join(", ") || "Artist";
        const title = meta.title || "Title";
        const cover = meta.cover_url;
        const notes = state.labelNotes.get(releaseId) || "";
        const bpmMap = state.trackBpm.get(releaseId) || {};
        const keyMap = state.trackKey.get(releaseId) || {};
        const showBpmKey = state.labelShowBpmKey.get(releaseId) || false;

        const fontSizeHeader = 16 + state.fontSizeOffset;
        const fontSizeTitle = 13 + state.fontSizeOffset;
        const fontSizeTable = 11 + state.fontSizeOffset;

        const coverHtml = cover
          ? `<img src="${escapeHtml(cover)}" alt="Cover" loading="lazy" referrerpolicy="no-referrer" />`
          : `<div class="coverPlaceholder" aria-label="No cover"></div>`;

        // Reconstruir tabela
        const tracks = meta.tracklist || [];
        const rows = tracks.map((t, idx) => {
          const pos = t.position || "";
          const trackTitle = t.title || "";
          const trackArtist = t.artist || "";
          const dur = t.duration || "";
          const bpm = bpmMap[idx] || "";
          const key = keyMap[idx] || "";
          const bpmClass = showBpmKey ? "" : "hidden";
          const keyClass = showBpmKey ? "" : "hidden";
          
          // Se há artista, mostra "Artist - Title", senão apenas "Title"
          const trackDisplay = trackArtist ? `${escapeHtml(trackArtist)} - ${escapeHtml(trackTitle)}` : escapeHtml(trackTitle);
          
          return `
            <tr>
              <td class="track-position">${escapeHtml(pos)}</td>
              <td class="track-title">${trackDisplay}</td>
              <td class="track-bpm ${bpmClass}">${escapeHtml(bpm)}</td>
              <td class="track-key ${keyClass}">${escapeHtml(key)}</td>
              <td class="track-duration">${escapeHtml(dur)}</td>
            </tr>
          `;
        }).join("");
        const bpmHeader = showBpmKey ? '<th class="track-bpm">BPM</th>' : '<th class="track-bpm hidden">BPM</th>';
        const keyHeader = showBpmKey ? '<th class="track-key">KEY</th>' : '<th class="track-key hidden">KEY</th>';
        const tableHtml = tracks.length ? `<table class="label-table"><thead><tr><th></th><th></th>${bpmHeader}${keyHeader}<th></th></tr></thead><tbody>${rows}</tbody></table>` : "";

        const footerHtml = buildFooter(meta);
        const qrHtml = qr ? `<img class="qr-code" src="${escapeHtml(qr)}" alt="QR" />` : "";
        const notesHtml = notes ? `<div class="label-notes visible"><div class="label-notes-content" style="font-size:11px;color:#666;white-space:pre-wrap;">${escapeHtml(notes)}</div></div>` : "";

        const spacing = 12 + (state.spacingOffset * 12);

        pages.push(`
          <div class="labelCard" style="margin-bottom: ${spacing}px;">
            <div class="label">
              <div class="label-cover">${coverHtml}</div>
              <div class="label-content">
                ${qrHtml}
                <div class="label-header" style="font-size: ${fontSizeHeader}px; color: ${state.titleColor};">${escapeHtml(artist)}</div>
                <div class="label-title" style="font-size: ${fontSizeTitle}px; color: ${state.subtitleColor};">${escapeHtml(title)}</div>
                ${tableHtml}
                <div class="label-footer">${footerHtml}</div>
                ${notesHtml}
              </div>
            </div>
          </div>
        `);
      }

      const spacing = 12 + (state.spacingOffset * 12);
      const css = document.querySelector("style").textContent || "";
      const htmlDoc = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Discogs Labels (Export)</title>
  <style>${css}</style>
</head>
<body>
  <div class="labelsRoot">
    <div class="labelsBody"><div class="labelsStack" style="gap: ${spacing}px;">${pages.join("\n")}</div></div>
  </div>
</body>
</html>`;

      const blob = new Blob([htmlDoc], { type: "text/html;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      const ts = new Date().toISOString().slice(0,19).replaceAll(":", "").replace("T", "_");
      a.href = url;
      a.download = `simple_discogs_label_generator_${ts}.html`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      setStatus("Export complete (HTML file downloaded).", "ok");
    }

    function exportReleaseList() {
      if (!state.releases.length) {
        setStatus("No releases loaded. Load your collection first.", "err");
        return;
      }

      const selected = Array.from(state.selected);
      if (!selected.length) {
        setStatus("No releases selected.", "err");
        return;
      }

      // Gerar lista no formato: "Artist" - "Release" ["Cat. number"] (year)
      const lines = [];
      for (const releaseId of selected) {
        const item = state.releases.find(r => r.basic_information?.id === releaseId);
        if (!item) continue;

        const basic = item.basic_information;
        const artists = (basic.artists || []).map(a => a.name).filter(Boolean).join(", ") || "Unknown Artist";
        const title = basic.title || "Unknown Title";
        const year = basic.year ? String(basic.year) : "";
        const catno = (basic.labels || []).map(l => l.catno).filter(Boolean)[0] || "";

        let line = `${artists} - ${title}`;
        if (catno) line += ` [${catno}]`;
        if (year) line += ` (${year})`;
        
        lines.push(line);
      }

      // Criar e baixar arquivo de texto
      const content = lines.join("\n");
      const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
      const url = URL.createObjectURL(blob);
      const a = document.createElement("a");
      const ts = new Date().toISOString().slice(0,10);
      a.href = url;
      a.download = `discogs_release_list_${ts}.txt`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
      setStatus(`Release list exported: ${lines.length} releases.`, "ok");
    }

    // Wire UI
    $("btnStart").addEventListener("click", startVerifyAndLoad);
    $("btnGenerate").addEventListener("click", generateLabels);
    $("btnExport").addEventListener("click", exportHtml);
    $("btnExportList").addEventListener("click", exportReleaseList);

    $("filter").addEventListener("input", renderReleaseList);
    $("releaseList").addEventListener("click", (e) => {
      const target = e.target;
      const itemEl = target instanceof Element ? target.closest(".listItem") : null;
      if (!itemEl) return;
      const id = Number(itemEl.getAttribute("data-release-id"));
      if (!id) return;
      if (state.selected.has(id)) state.selected.delete(id);
      else state.selected.add(id);
      renderReleaseList();
    });

    $("btnAll").addEventListener("click", () => {
      for (const id of getVisibleReleaseIds()) state.selected.add(id);
      renderReleaseList();
    });
    $("btnNone").addEventListener("click", () => {
      state.selected.clear();
      renderReleaseList();
    });

    // Controles do preview
    $("btnFontSizeDown").addEventListener("click", () => {
      state.fontSizeOffset = Math.max(-10, state.fontSizeOffset - 1);
      $("fontSizeDisplay").value = state.fontSizeOffset;
      applyPreviewSettings();
    });

    $("btnFontSizeUp").addEventListener("click", () => {
      state.fontSizeOffset = Math.min(10, state.fontSizeOffset + 1);
      $("fontSizeDisplay").value = state.fontSizeOffset;
      applyPreviewSettings();
    });

    $("titleColor").addEventListener("input", (e) => {
      state.titleColor = e.target.value;
      applyPreviewSettings();
    });

    $("subtitleColor").addEventListener("input", (e) => {
      state.subtitleColor = e.target.value;
      applyPreviewSettings();
    });


    $("btnSpacingDown").addEventListener("click", () => {
      state.spacingOffset = Math.max(-5, state.spacingOffset - 1);
      $("spacingDisplay").value = state.spacingOffset;
      applyPreviewSettings();
    });

    $("btnSpacingUp").addEventListener("click", () => {
      state.spacingOffset = Math.min(10, state.spacingOffset + 1);
      $("spacingDisplay").value = state.spacingOffset;
      applyPreviewSettings();
    });

    // Inicializar controles
    $("fontSizeDisplay").value = state.fontSizeOffset;
    $("spacingDisplay").value = state.spacingOffset;
    $("titleColor").value = state.titleColor;
    $("subtitleColor").value = state.subtitleColor;

    // Inicial
    setBusy(false);
    setStatus("Ready. Verify token + Load collection → Generate labels.");
  </script>
</body>
</html>

